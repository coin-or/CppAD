/* --------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-06 Bradley M. Bell

CppAD is distributed under multiple licenses. This distribution is under
the terms of the 
                    Common Public License Version 1.0.

A copy of this license is included in the COPYING file of this distribution.
Please visit http://www.coin-or.org/CppAD/ for information on other licenses.
-------------------------------------------------------------------------- */
/*
$begin exp_apx_seq$$
$spell
	cpp
	exp_apx_seq
	bool
$$

$section exp_apx: Operation Sequence and Zero Order Forward Mode$$

$index exp_apx, operation sequence$$
$index example, operation sequence$$
$index operation, sequence example$$
$index sequence, example operation$$

$index zero, order forward$$
$index order, zero forward$$
$index forward, zero order$$

$head Definition$$
An atomic $italic Type$$ operation is an operation
that has a $italic Type$$ result and is not made up of 
other more basic operations.
A sequence of atomic $italic Type$$ operations is called a
$italic Type$$ operation sequence.
Given an C++ algorithm and its inputs,
there is a corresponding $italic Type$$ operation sequence for each type. 
If $italic Type$$ is clear from the context, 
we drop it and just refer to the operation sequence.

$head Corresponding Function$$
Suppose that we use the algorithm $xref/exp_apx.hpp/$$
to compute $latex {\rm exp\_apx} (x, e)$$ 
with $latex x$$ is equal to .5
and $latex e$$ is equal to .2. 
For this case, our approximation of the exponential function is
$latex \[
{\rm exp\_apx} (x, e) =   1 + x + x^2 / 2 
=   1 + .5 + .25 / 2 
=   1.625
\] $$
An algorithmic differentiation package
does not operate on the mathematical form
but rather on a corresponding operation sequence. 

$head Notation$$
We use the symbol $latex v_j$$ for the value assigned
to the object $latex v$$ in the $th j$$ execution of 
the $code while$$ loop in the algorithm defined by 
$cref/exp_apx.hpp/$$.
We use $latex v_0$$ for values that are assigned before
the $code while$$ loop.
The initialization section always sets
$latex r_0$$,
$latex s_0$$,
and
$latex k_0$$ equal to one.
Hence the $italic Type$$ values 
$latex r_0$$, $latex s_0$$ and $latex k_0$$ do not
depend on the input variables $italic x$$ or $italic e$$.

$head Parameter$$
We refer to symbols that do not depend on the input variables
as operation sequence parameters.

$head Variable$$
We refer to other symbols as operation sequence variables. 

$head Trace$$
We consider the case where $cref/exp_apx.hpp/$$ is executed with
$latex x = .5$$ and $latex e = .2$$.
The table below contains a trace of the corresponding operation sequence
and zero order forward sweep values.
Note that the comparisons
$code r > e$$ and $code  Type(0) > x $$
have results of type
$code bool$$ and hence are not part of the $italic Type$$ operation sequence.

$subhead Index$$
The Index column contains the index in the operation sequence
of the corresponding atomic operation. 
A Forward sweep starts with the first operation 
and ends with the last.

$subhead Code$$
The Code column contains the C++ source code corresponding 
to the corresponding atomic operation in the sequence. 

$subhead Operation$$
The Operation column contains the 
mathematical function corresponding to each atomic operation in the sequence.

$subhead Value_0$$
The Value_0 column contains the function value
corresponding to each atomic operation in the sequence.
These are referred to as the zero order forward mode values.
They are referred to as forward mode because
the computations are done in the same order as the original algorithm; i.e,
in order of increasing index.
They are referred to as zero order because function values
correspond to derivatives of order zero.

$subhead Table$$
$center
$table
$bold Index$$
	$cnext $pre  $$ $cnext $bold Code$$ 
	$cnext $pre  $$ $cnext $bold Operation$$
	$cnext $pre  $$ $cnext $bold Value_0$$
$rnext
1
	$cnext $pre  $$ $cnext $code a = x$$
	$cnext $cnext $latex a_0 = x $$ 
	$cnext $cnext = 0.5      
$rnext
2
	$cnext $pre  $$ $cnext $code q  = a * r$$
	$cnext $cnext $latex q_1 = r_0 * a_0 $$ 
	$cnext $cnext = 0.5      
$rnext
3
	$cnext $pre  $$ $cnext $code r  = q / k$$
	$cnext $cnext $latex r_1 = q_1 / k_0 $$ 
	$cnext $cnext = 0.5      
$rnext
4
	$cnext $pre  $$ $cnext $code s  = s + r$$
	$cnext $cnext $latex s_1 = s_0 + r_1 $$ 
	$cnext $cnext = 1.5      
$rnext
5
	$cnext $pre  $$ $cnext $code k  = k + Type(1)$$
	$cnext $cnext $latex k_1 = k_0 + 1 $$ 
	$cnext $cnext = 2        
$rnext
6
	$cnext $pre  $$ $cnext $code q  = a * r$$
	$cnext $cnext $latex q_2 = r_1 * a_0 $$ 
	$cnext $cnext = 0.25     
$rnext
7
	$cnext $pre  $$ $cnext $code r  = q / k$$
	$cnext $cnext $latex r_2 = q_2 / k_1 $$ 
	$cnext $cnext = 0.125    
$rnext
8
	$cnext $pre  $$ $cnext $code s  = s + r$$
	$cnext $cnext $latex s_2 = s_1 + r_2 $$ 
	$cnext $cnext = 1.625    
$rnext
9
	$cnext $pre  $$ $cnext $code k  = k + Type(1)$$
	$cnext $cnext $latex k_2 = k_1 + 1 $$ 
	$cnext $cnext = 3        
$tend
$$

$head Return  Value$$
The return value of the algorithm for this case is
$latex s_2$$ which is equal to 1.625.

$head Comparisons$$
If $latex x$$ were negative,
or if $latex e$$ were a much smaller or much larger value,
the results of the following comparisons could be different:
$codep
	if( Type(0) > x ) 
	while(r > e)
$$
This in turn would result in a different operation sequence.
Thus the operation sequence above only corresponds to 
$cref/exp_apx.hpp/$$
for values of $latex x$$ and $latex e$$ within a certain range.
Note that there is a neighborhood
of $latex x = 0.5$$ for which the comparisons would have the 
same result and hence the operation sequence would be the same.

$head Symbols$$
$index operation, symbol$$
$index symbol, operation$$
The symbols for an operation sequence is a
sequence of unique names for each atomic operation.
For example, the symbols for the operation sequence above are:
$latex \[
	r_0, s_0, k_0, a_0, q_1, r_1, s_1, k_1, q_2, r_2, s_2
\]$$
In an abuse of notation, we use a symbol for both the
function and the value of the function corresponding to an atomic operation. 
Note that each time a $italic Type$$ object is assigned a value
there is a different symbol corresponding to the assignment.

$children%
	introduction/exp_apx/exp_apx_seq.cpp
%$$
$head Verification$$
The file $xref/exp_apx_seq.cpp/$$ contains a routine 
which verifies the values computed above.
It returns true for success and false for failure.

$head Exercises$$
$list number$$
Suppose that $latex x = .1$$,
what is the result of a zero order forward sweep for 
the operation sequence above; 
i.e., what are the corresponding values for
$latex \[
	r_0, s_0, k_0, a_0, q_1, r_1, s_1, k_1, q_2, r_2, s_2
\]$$
$lnext
Create a modified version of 
$cref/exp_apx_seq.cpp/$$ that verifies the values you obtained
for the previous exercise.
$lnext
Create and run a main program that reports the result of calling 
the modified version 
of $cref/exp_apx_seq.cpp/$$ in the previous exercise.
$lend


$end
*/
