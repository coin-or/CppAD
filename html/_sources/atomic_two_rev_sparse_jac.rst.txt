lines 8-114 of file: include/cppad/core/atomic/two/rev_sparse_jac.hpp

{xrst_begin atomic_two_rev_sparse_jac}
{xrst_spell
   rt
   st
}

Atomic Reverse Jacobian Sparsity Patterns
#########################################

Syntax
******

   *ok* = *afun* . ``rev_sparse_jac`` ( *q* , *rt* , *st* , *x* )

Deprecated 2016-06-27
*********************

   *ok* = *afun* . ``rev_sparse_jac`` ( *q* , *rt* , *st* )

Purpose
*******
This function is used by
:ref:`RevSparseJac-name` to compute
Jacobian sparsity patterns.
If you are using :ref:`RevSparseJac-name` ,
one of the versions of this
virtual function must be defined by the
:ref:`atomic_two_ctor@atomic_user` class.

For a fixed matrix :math:`R \in \B{R}^{q \times m}`,
the Jacobian of :math:`R * f( x )` with respect to :math:`x \in \B{R}^n` is

.. math::

   S(x) = R * f^{(1)} (x)

Given a :ref:`glossary@Sparsity Pattern` for :math:`R`,
``rev_sparse_jac`` computes a sparsity pattern for :math:`S(x)`.

Implementation
**************
If you are using
:ref:`RevSparseJac-name` or :ref:`ForSparseHes-name` ,
this virtual function must be defined by the
:ref:`atomic_two_ctor@atomic_user` class.

q
=
The argument *q* has prototype

   ``size_t`` *q*

It specifies the number of rows in
:math:`R \in \B{R}^{q \times m}` and the Jacobian
:math:`S(x) \in \B{R}^{q \times n}`.

rt
==
This argument has prototype

   ``const`` *atomic_sparsity* & *rt*

and is a
:ref:`atomic_two_option@atomic_sparsity` pattern for
:math:`R^\R{T} \in \B{R}^{m \times q}`.

st
==
This argument has prototype

   *atomic_sparsity* & *st*

The input value of its elements
are not specified (must not matter).
Upon return, *s* is a
:ref:`atomic_two_option@atomic_sparsity` pattern for
:math:`S(x)^\R{T} \in \B{R}^{n \times q}`.

x
=
The argument has prototype

   ``const CppAD::vector<`` *Base* >& *x*

and size is equal to the *n* .
This is the :ref:`Value-name` corresponding to the parameters in the
vector :ref:`atomic_two_afun@ax` (when the atomic function was called).
To be specific, if

| |tab| ``if`` ( ``Parameter`` ( *ax* [ *i* ]) == ``true`` )
| |tab| |tab| *x* [ *i* ] = ``Value`` ( *ax* [ *i* ] );
| |tab| ``else``
| |tab| |tab| *x* [ *i* ] = ``CppAD::numeric_limits<`` *Base* >:: ``quiet_NaN`` ();

The version of this function with out the *x* argument is deprecated;
i.e., you should include the argument even if you do not use it.

ok
**
The return value *ok* has prototype

   ``bool`` *ok*

If it is ``true`` , the corresponding evaluation succeeded,
otherwise it failed.

{xrst_end atomic_two_rev_sparse_jac}
