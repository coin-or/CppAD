{xrst_comment
SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
SPDX-FileCopyrightText: Bradley M. Bell <bradbell@seanet.com>
SPDX-FileContributor: 2024 Bradley M. Bell

This xrst template file documents the multiple directrion forward arguments:
   n_dir, cap_order, taylor
}

n_dir
*****
number of directions that we are computing the Taylor coefficient for.

cap_order
*********
is the maximum number of orders that can fit in *taylor* .

taylor
******

per_variable
============
For each variable there is one Taylor coefficient of order zero
and *n_dir* coefficients for orders greater than zero.
The taylor coefficients capacity per variable is::

   per_variable = (cap_order - 1) * n_dir + 1

(j, k, ell)
===========
For variable index j, order k, and direction index ell::

   if k == 0
      (j, k, ell) = j * per_variable
   else
      (j, k, ell) = j * per_variable + (k-1) * n_dir + 1 + ell

The value taylor[ (j, k, ell) ] is the
Taylor coefficient corresponding to
the variable with index j, the order k, and the direction with index ell.

n_dir = 1
=========
If *n_dir* is equal to one then *ell* is zero and::

   (j, k, ell) = j * cap_order + k

n_res
=====
If this is a unary operator and it has an auxiliary result,
*n_res* is two.
Other *n_res* is one; see :ref:`var_unary_op@n_res` .

Input
=====
::

   for j = 0, ..., i_z - n_res,
      for k = 0 , ... , order_up
         for ell = 0 , ... , n_dir - 1
            taylor [ (j, k, ell) ] is an input

   for k = 0 , ... , order_up - 1
      for ell = 0 , ... , n_dir - 1
         taylor [ (i_z, k, ell) ] is an input
         if n_res == 2
            taylor [ (i_z - 1, k, ell) ] is an input

Output
======
::

   for ell = 0, ... , n_dir - 1
      taylor [ (i_z, order_up, ell) ] is an output
      if n_res == 2
         taylor[ (i_z - 1, order_up, ell) ] is an output.
