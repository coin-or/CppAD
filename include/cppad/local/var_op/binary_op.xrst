# SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
# SPDX-FileCopyrightText: Bradley M. Bell <bradbell@seanet.com>
# SPDX-FileContributor: 2003-24 Bradley M. Bell
# ----------------------------------------------------------------------------
{xrst_begin_parent var_binary_op dev}
{xrst_spell
   addpv
   addvv
   mulpv
   mulvv
   divpv
   divvp
   divvv
   subpv
   subvp
   subvv
   zmulpv
   zmulvp
   zmulvv
}

Binary Operators
################
All these operators have the same prototype and could be implemented as
virtual functions for a binary base case.
Compilers can not optimize across virtual function calls and testing indicates
that a virtual function implementation is significant slower.

User Syntax
***********
| *z* = *Fun* ( *x* , *y* )
| *z* = *x* *Op* *y*

x
*
is a parameter or variable and is the first argument for this operator.

y
*
is a parameter or variable and is the second argument for this operator.

z
*
is the result for this operator which is also a variable.

Base
****
base type for the operator; i.e., this operation was recorded
using AD<Base> and computations by these operators done using type Base.

Fun
***

.. csv-table::
   :widths: auto
   :header-rows: 1

   op_code,      Fun,  Op,         x,         y,  z
   AddpvOp,    addpv,   \+, parameter,  variable,  *x* + *y*
   AddvvOp,    addvv,   \+,  variable,  variable,  *x* + *y*
   DivpvOp,    divpv,   \/, parameter,  variable,  *x* / *y*
   DivvpOp,    divvp,   \/,  variable, parameter,  *x* / *y*
   DivvvOp,    divvv,   \/,  variable,  variable,  *x* / *y*
   MulpvOp,    mulpv,   \*, parameter,  variable,  *x* * *y*
   MulvvOp,    mulvv,   \*,  variable,  variable,  *x* * *y*
   SubpvOp,    subpv,   \-, parameter,  variable,  *x* - *y*
   SubvpOp,    subvp,   \-,  variable, parameter,  *x* - *y*
   SubvvOp,    subvv,   \-,  variable,  variable,  *x* - *y*
   ZmulpvOp,   zmulpv,  \-, parameter,  variable,  azmul( *x* , *y* )
   ZmulvpOp,   zmulvp,  \-,  variable, parameter,  azmul( *x* , *y* )
   ZmulvvOp,   zmulvv,  \-,  variable,  variable,  azmul( *x* , *y* )

i_z
***
is the variable index corresponding to *z* .

arg
***

arg[0]
======
If *x* is a variable (parameter)
*arg* [0] is the variable index (parameter index) corresponding to *x* .

arg[1]
======
If *y* is a variable (parameter)
*arg* [1] is the variable index (parameter index) corresponding to *y* .

parameter
*********
maps parameter indices to parameter values.

{xrst_end var_binary_op}
------------------------------------------------------------------------------
{xrst_begin var_binary_forward_0 dev}

Zero Order Forward Binary Variable Operators
############################################

Prototype
*********
{xrst_code cpp}
template <class Base>
inline void Fun_forward_0(
   size_t        i_z         ,
   const addr_t* arg         ,
   const Base*   parameter   ,
   size_t        cap_order   ,
   Base*         taylor      )
{xrst_code}

Base, x, y, z, Fun, i_z, arg, parameter
***************************************
see
:ref:`var_binary_op@Base` ,
:ref:`var_binary_op@x` ,
:ref:`var_binary_op@y` ,
:ref:`var_binary_op@z` ,
:ref:`var_binary_op@Fun` ,
:ref:`var_binary_op@i_z` ,
:ref:`var_binary_op@arg` ,
:ref:`var_binary_op@parameter`

cap_order
*********
number of columns in the matrix containing the Taylor coefficients.

taylor
******
The Taylor coefficient corresponding to variable *i* and order *k* is

   *taylor* [ *i* * *cap_order* + *k*  ]

Input
=====
The zero order Taylor coefficients
for variables with index *i* less than *i_z* .

Output
======
The zero order Taylor coefficients for variables with index *i_z* .

{xrst_end var_binary_forward_0}
------------------------------------------------------------------------------
{xrst_begin var_binary_forward_op dev}

General Forward Binary Variable Operators
#########################################

Prototype
*********
{xrst_code cpp}
template <class Base>
inline void Fun_forward_op(
   size_t        order_low   ,
   size_t        order_up    ,
   size_t        i_z         ,
   const addr_t* arg         ,
   const Base*   parameter   ,
   size_t        cap_order   ,
   Base*         taylor      )
{xrst_code}

Base, x, y, z, Fun, i_z, arg, parameter
***************************************
see
:ref:`var_binary_op@Base` ,
:ref:`var_binary_op@x` ,
:ref:`var_binary_op@y` ,
:ref:`var_binary_op@z` ,
:ref:`var_binary_op@Fun` ,
:ref:`var_binary_op@i_z` ,
:ref:`var_binary_op@arg` ,
:ref:`var_binary_op@parameter`

order_low
*********
is lowest order of the Taylor coefficient that we are computing.

order_up
********
is highest order of the Taylor coefficient that we are computing,
*p* <= *q* .

cap_order
*********
number of columns in the matrix containing the Taylor coefficients.

taylor
******
The Taylor coefficient corresponding to variable *i* and order *k* is

   *taylor* [ *i* * *cap_order* + *k*  ]

Input
=====
#. The Taylor coefficients up to order *q*
   for variables with index *i* less than *i_z* .
#. The Taylor coefficients up to order *p* - 1
   for the variable with index *i_z* .

Output
======
The Taylor coefficients up to order *q* for the variable with index *i_z* .

{xrst_end var_binary_forward_op}
------------------------------------------------------------------------------
{xrst_begin var_binary_forward_dir dev}
{xrst_spell
}

Multiple Direction Forward Binary Operators
###########################################

Prototype
*********
{xrst_code cpp}
template <class Base>
inline void Fun_forward_dir(
   size_t        order_up    ,
   size_t        n_dir       ,
   size_t        i_z         ,
   const addr_t* arg         ,
   const Base*   parameter   ,
   size_t        cap_order   ,
   Base*         taylor      )
{xrst_code}

Base, x, y, z, Fun, i_z, arg, parameter
***************************************
see
:ref:`var_binary_op@Base` ,
:ref:`var_binary_op@x` ,
:ref:`var_binary_op@y` ,
:ref:`var_binary_op@z` ,
:ref:`var_binary_op@Fun` ,
:ref:`var_binary_op@i_z` ,
:ref:`var_binary_op@arg` ,
:ref:`var_binary_op@parameter`

order_up
********
order of the Taylor coefficients that we are computing.

n_dir
*****
number of directions that we are computing the Taylor coefficient for.

{xrst_comment document cap_order, taylor}
{xrst_template ,
   include/cppad/local/var_op/forward_dir.xrst
}

{xrst_end var_binary_forward_dir}
------------------------------------------------------------------------------
{xrst_begin var_binary_reverse_op dev}

Reverse Mode Binary Operators
#############################

Prototype
*********
{xrst_code cpp}
template <class Base>
inline void Fun_reverse_op(
   size_t        i_z          ,
   const addr_t* arg          ,
   const Base*   parameter    ,
   size_t        cap_order    ,
   const Base*   taylor       ,
   size_t        n_order      ,
   Base*         partial      )
{xrst_code}

Base, x, y, z, Fun, i_z, arg, parameter
***************************************
see
:ref:`var_binary_op@Base` ,
:ref:`var_binary_op@x` ,
:ref:`var_binary_op@y` ,
:ref:`var_binary_op@z` ,
:ref:`var_binary_op@Fun` ,
:ref:`var_binary_op@i_z` ,
:ref:`var_binary_op@arg` ,
:ref:`var_binary_op@parameter`

cap_order
*********
number of columns in the matrix containing the Taylor coefficients.

taylor
******
The Taylor coefficient corresponding to variable *i* and order *k* is

   *taylor* [ *i* * *cap_order* + *k*  ]

{xrst_comment document n_order, partial}
{xrst_template ;
   include/cppad/local/var_op/reverse.xrst
   @x, y@ ; x
}

{xrst_end var_binary_reverse_op}
------------------------------------------------------------------------------
