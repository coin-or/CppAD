<html>
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath:  [ ['@(@','@)@'] ] ,
    displayMath: [ ['@[@','@]@'] ]
  }
});
</script>
<script type='text/javascript' src=
'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=default'
>
</script>
<head>
<title>exp_eps: Second Order Reverse Sweep</title>
<meta http-equiv='Content-Type' content='text/html' charset='utf-8'>
<meta name="description" id="description" content="exp_eps: Second Order Reverse Sweep">
<meta name="keywords" id="keywords" content=" exp_eps: second order reverse sweep purpose mathematical form epsilon f_7 index 7: f_6 6: f_5 5: f_4 4: f_3 3: f_2 2: f_1 verification exercises ">
<style type='text/css'>
body { color : black }
body { background-color : white }
A:link { color : blue }
A:visited { color : purple }
A:active { color : purple }
</style>
<script type='text/javascript' language='JavaScript' src='_exp_eps_rev2_htm.js'>
</script>
</head>
<body>
<table><tr>
<td>
<a href="https://coin-or.github.io/CppAD" target="_top"><img border="0" src="_image.gif"></a>
</td>
<td><a href="exp_eps_for2.cpp.htm" target="_top">Prev</a>
</td><td><a href="exp_eps_rev2.cpp.htm" target="_top">Next</a>
</td><td>
<select onchange='choose_across0(this)'>
<option>Index-&gt;</option>
<option>contents</option>
<option>reference</option>
<option>index</option>
<option>search</option>
<option>external</option>
</select>
</td>
<td>
<select onchange='choose_up0(this)'>
<option>Up-&gt;</option>
<option>CppAD</option>
<option>Theory</option>
<option>Introduction</option>
<option>exp_eps</option>
<option>exp_eps_rev2</option>
</select>
</td>
<td>
<script type='text/javascript' language='JavaScript' src='_childtable_theory_htm.js'></script>
</td>
<td>
<script type='text/javascript' language='JavaScript' src='_childtable_introduction_htm.js'></script>
</td>
<td>
<script type='text/javascript' language='JavaScript' src='_childtable_exp_eps_htm.js'></script>
</td>
<td>
<script type='text/javascript' language='JavaScript' src='_childtable_exp_eps_rev2_htm.js'></script>
</td>
<td>
<select onchange='choose_current0(this)'>
<option>Headings-&gt;</option>
<option>Purpose</option>
<option>Mathematical Form</option>
<option>epsilon</option>
<option>f_7</option>
<option>Index 7: f_6</option>
<option>Index 6: f_5</option>
<option>Index 5: f_4</option>
<option>Index 4: f_3</option>
<option>Index 3: f_2</option>
<option>Index 2: f_1</option>
<option>Verification</option>
<option>Exercises</option>
</select>
</td>
</tr></table><br>
@(@\newcommand{\W}[1]{ \; #1 \; }
\newcommand{\R}[1]{ {\rm #1} }
\newcommand{\B}[1]{ {\bf #1} }
\newcommand{\D}[2]{ \frac{\partial #1}{\partial #2} }
\newcommand{\DD}[3]{ \frac{\partial^2 #1}{\partial #2 \partial #3} }
\newcommand{\Dpow}[2]{ \frac{\partial^{#1}}{\partial  {#2}^{#1}} }
\newcommand{\dpow}[2]{ \frac{ {\rm d}^{#1}}{{\rm d}\, {#2}^{#1}} }@)@



<b>This is old CppAD documentation:</b> Here is a link to its
<a href="http://coin-or.github.io/CppAD" target="_top"><span style='white-space: nowrap'>current&nbsp;documentation</span></a>
.

<center><b><big><big>exp_eps: Second Order Reverse Sweep</big></big></b></center>
<br>
<b><big><a name="Purpose" id="Purpose">Purpose</a></big></b>
<br>
In general, a second order reverse sweep is given the
<a href="exp_eps_for1.htm#First Order Expansion" target="_top"><span style='white-space: nowrap'>first&nbsp;order&nbsp;expansion</span></a>

for all of the variables in an operation sequence.
Given a choice of a particular variable,
it computes the derivative,
of that variables first order expansion coefficient,
with respect to all of the independent variables.

<br>
<br>
<b><big><a name="Mathematical Form" id="Mathematical Form">Mathematical Form</a></big></b>
<br>
Suppose that we use the algorithm <a href="exp_eps.hpp.htm" target="_top"><span style='white-space: nowrap'>exp_eps.hpp</span></a>

to compute 
<code><font color="blue"><span style='white-space: nowrap'>exp_eps(</span></font><i><font color="black"><span style='white-space: nowrap'>x</span></font></i><font color="blue"><span style='white-space: nowrap'>,&nbsp;</span></font><i><font color="black"><span style='white-space: nowrap'>epsilon</span></font></i><font color="blue"><span style='white-space: nowrap'>)</span></font></code>

with 
<code><i><font color="black"><span style='white-space: nowrap'>x</span></font></i></code>
 is equal to .5
and 
<code><i><font color="black"><span style='white-space: nowrap'>epsilon</span></font></i></code>
 is equal to .2.
For this case, the mathematical function for the operation sequence
corresponding to <code><font color="blue">exp_eps</font></code> is
<small>@[@

f ( x , \varepsilon ) =   1 + x + x^2 / 2

@]@</small>
The corresponding derivative of the
partial derivative with respect to <small>@(@
x
@)@</small> is
<small>@[@

\begin{array}{rcl}
\Dpow{2}{x} f ( x , \varepsilon ) & = &  1
\\
\partial_\varepsilon \partial_x f ( x , \varepsilon ) & = &  0
\end{array}

@]@</small>

<br>
<br>
<b><big><a name="epsilon" id="epsilon">epsilon</a></big></b>
<br>
Since <small>@(@
\varepsilon
@)@</small> is an independent variable,
it could included as an argument to all of the
<small>@(@
f_j
@)@</small> functions below.
The result would be that all the partials with respect to
<small>@(@
\varepsilon
@)@</small> would be zero and hence we drop it to simplify
the presentation.

<br>
<br>
<b><big><a name="f_7" id="f_7">f_7</a></big></b>
<br>
In reverse mode we choose one dependent variable and
compute its derivative with respect to all the independent variables.
For our example, we chose the value returned by <a href="exp_eps.hpp.htm" target="_top"><span style='white-space: nowrap'>exp_eps.hpp</span></a>

which is <small>@(@
v_7
@)@</small>.
We begin with the function <small>@(@
f_7
@)@</small> where <small>@(@
v_7
@)@</small>
is both an argument and the value of the function; i.e.,
<small>@[@

\begin{array}{rcl}
f_7 \left(
    v_1^{(0)} , v_1^{(1)} , \ldots , v_7^{(0)} , v_7^{(1)}
\right)
& = & v_7^{(1)}
\\
\D{f_7}{v_7^{(1)}} & = & 1
\end{array}

@]@</small>
All the other partial derivatives of <small>@(@
f_7
@)@</small> are zero.

<br>
<br>
<b><big><a name="Index 7: f_6" id="Index 7: f_6">Index 7: f_6</a></big></b>
<br>
The last operation has index 7,
<small>@[@

\begin{array}{rcl}
    v_7^{(0)} & = &   v_4^{(0)} + v_6^{(0)}
    \\
    v_7^{(1)} & = &   v_4^{(1)} + v_6^{(1)}
\end{array}

@]@</small>
We define the function
<small>@(@
f_6 \left( v_1^{(0)} , \ldots , v_6^{(1)} \right)
@)@</small>
as equal to <small>@(@
f_7
@)@</small>
except that <small>@(@
v_7^{(0)}
@)@</small> and <small>@(@
v_7^{(1)}
@)@</small> are eliminated using
this operation; i.e.
<small>@[@

f_6  =
f_7 \left[ v_1^{(0)} , \ldots , v_6^{(1)} ,
    v_7^{(0)} \left( v_4^{(0)} , v_6^{(0)} \right)  ,
    v_7^{(1)} \left( v_4^{(1)} , v_6^{(1)} \right)
\right]

@]@</small>
It follows that
<small>@[@

\begin{array}{rcll}
\D{f_6}{v_4^{(1)}}
& = & \D{f_7}{v_4^{(1)}} +
    \D{f_7}{v_7^{(1)}} * \D{v_7^{(1)}}{v_4^{(1)}}
& = 1
\\
\D{f_6}{v_6^{(1)}}
& = & \D{f_7}{v_6^{(1)}} +
    \D{f_7}{v_7^{(1)}} * \D{v_7^{(1)}}{v_6^{(1)}}
& = 1
\end{array}

@]@</small>
All the other partial derivatives of <small>@(@
f_6
@)@</small> are zero.

<br>
<br>
<b><big><a name="Index 6: f_5" id="Index 6: f_5">Index 6: f_5</a></big></b>
<br>
The previous operation has index 6,
<small>@[@

\begin{array}{rcl}
    v_6^{(0)} & = & v_5^{(0)} / 2
    \\
    v_6^{(1)} & = & v_5^{(1)} / 2
\end{array}

@]@</small>
We define the function
<small>@(@
f_5 \left( v_1^{(0)} , \ldots , v_5^{(1)} \right)
@)@</small>
as equal to <small>@(@
f_6
@)@</small>
except that <small>@(@
v_6^{(0)}
@)@</small> and <small>@(@
v_6^{(1)}
@)@</small> are eliminated using
this operation; i.e.
<small>@[@

f_5 =
f_6 \left[ v_1^{(0)} , \ldots , v_5^{(1)} ,
    v_6^{(0)} \left( v_5^{(0)} \right) ,
    v_6^{(1)} \left( v_5^{(1)} \right)
\right]

@]@</small>
It follows that
<small>@[@

\begin{array}{rcll}
\D{f_5}{v_4^{(1)}}
& = & \D{f_6}{v_4^{(1)}}
& = 1
\\
\D{f_5}{v_5^{(1)}}
& = & \D{f_6}{v_5} +
    \D{f_6}{v_6^{(1)}} * \D{v_6^{(1)}}{v_5^{(1)}}
& = 0.5
\end{array}

@]@</small>
All the other partial derivatives of <small>@(@
f_5
@)@</small> are zero.

<br>
<br>
<b><big><a name="Index 5: f_4" id="Index 5: f_4">Index 5: f_4</a></big></b>
<br>
The previous operation has index 5,
<small>@[@

\begin{array}{rcl}
    v_5^{(0)} & = & v_3^{(0)} * v_1^{(0)}
    \\
    v_5^{(1)} & = & v_3^{(1)} * v_1^{(0)} + v_3^{(0)} * v_1^{(1)}
\end{array}

@]@</small>
We define the function
<small>@(@
f_4 \left( v_1^{(0)} , \ldots , v_4^{(1)} \right)
@)@</small>
as equal to <small>@(@
f_5
@)@</small>
except that <small>@(@
v_5^{(0)}
@)@</small> and <small>@(@
v_5^{(1)}
@)@</small> are eliminated using
this operation; i.e.
<small>@[@

f_4 =
f_5 \left[  v_1^{(0)} , \ldots , v_4^{(1)} ,
    v_5^{(0)} \left( v_1^{(0)}, v_3^{(0)} \right) ,
    v_5^{(1)} \left( v_1^{(0)}, v_1^{(1)}, v_3^{(0)} , v_3^{(1)} \right) ,
\right]

@]@</small>
Given the information from the forward sweep, we have
<small>@(@
v_1^{(0)} =  0.5
@)@</small>,
<small>@(@
v_3^{(0)} =  0.5
@)@</small>,
<small>@(@
v_1^{(1)} =  1
@)@</small>,
<small>@(@
v_3^{(1)} =  1
@)@</small>,
and the fact that the partial of <small>@(@
f_5
@)@</small> with respect to
<small>@(@
v_5^{(0)}
@)@</small> is zero, we have
<small>@[@

\begin{array}{rcll}
\D{f_4}{v_1^{(0)}}
& = & \D{f_5}{v_1^{(0)}}
  +   \D{f_5}{v_5^{(1)}} * \D{v_5^{(1)}}{v_1^{(0)}}
& = 0.5
\\
\D{f_4}{v_1^{(1)}}
& = & \D{f_5}{v_1^{(1)}}
  +   \D{f_5}{v_5^{(1)}} * \D{v_5^{(1)}}{v_1^{(1)}}
& = 0.25
\\
\D{f_4}{v_3^{(0)}}
& = & \D{f_5}{v_3^{(0)}}
  +   \D{f_5}{v_5^{(1)}} * \D{v_5^{(1)}}{v_3^{(0)}}
& = 0.5
\\
\D{f_4}{v_3^{(1)}}
& = & \D{f_3}{v_1^{(1)}}
  +   \D{f_5}{v_5^{(1)}} * \D{v_5^{(1)}}{v_3^{(1)}}
& = 0.25
\\
\D{f_4}{v_4^{(1)}}
& = & \D{f_5}{v_4^{(1)}}
& = 1
\end{array}

@]@</small>
All the other partial derivatives of <small>@(@
f_5
@)@</small> are zero.

<br>
<br>
<b><big><a name="Index 4: f_3" id="Index 4: f_3">Index 4: f_3</a></big></b>
<br>
The previous operation has index 4,
<small>@[@

\begin{array}{rcl}
    v_4^{(0)} = 1 + v_3^{(0)}
    \\
    v_4^{(1)} = v_3^{(1)}
\end{array}

@]@</small>
We define the function
<small>@(@
f_3 \left( v_1^{(0)} , \ldots , v_3^{(1)} \right)
@)@</small>
as equal to <small>@(@
f_4
@)@</small>
except that <small>@(@
v_4^{(0)}
@)@</small> and <small>@(@
v_4^{(1)}
@)@</small> are eliminated using
this operation; i.e.
<small>@[@

f_3 =
f_4 \left[ v_1^{(0)} , \ldots , v_3^{(1)} ,
    v_4^{(0)} \left( v_3^{(0)} \right) ,
    v_4^{(1)} \left( v_3^{(1)} \right)
\right]

@]@</small>
It follows that
<small>@[@

\begin{array}{rcll}
\D{f_3}{v_1^{(0)}}
& = & \D{f_4}{v_1^{(0)}}
& =  0.5
\\
\D{f_3}{v_1^{(1)}}
& = & \D{f_4}{v_1^{(1)}}
& =  0.25
\\
\D{f_3}{v_2^{(0)}}
& = & \D{f_4}{v_2^{(0)}}
& = 0
\\
\D{f_3}{v_2^{(1)}}
& = & \D{f_4}{v_2^{(1)}}
& = 0
\\
\D{f_3}{v_3^{(0)}}
& = & \D{f_4}{v_3^{(0)}}
  +   \D{f_4}{v_4^{(0)}} * \D{v_4^{(0)}}{v_3^{(0)}}
& = 0.5
\\
\D{f_3}{v_3^{(1)}}
& = & \D{f_4}{v_3^{(1)}}
  +   \D{f_4}{v_4^{(1)}} * \D{v_4^{(1)}}{v_3^{(1)}}
& = 1.25
\end{array}

@]@</small>


<br>
<br>
<b><big><a name="Index 3: f_2" id="Index 3: f_2">Index 3: f_2</a></big></b>
<br>
The previous operation has index 3,
<small>@[@

\begin{array}{rcl}
    v_3^{(0)} & = & v_2^{(0)} / 1
    \\
    v_3^{(1)} & = & v_2^{(1)} / 1
\end{array}

@]@</small>
We define the function
<small>@(@
f_2 \left( v_1^{(0)} , \ldots , v_2^{(1)} \right)
@)@</small>
as equal to <small>@(@
f_3
@)@</small>
except that <small>@(@
v_3^{(0)}
@)@</small> and <small>@(@
v_3^{(1)}
@)@</small> are eliminated using
this operation; i.e.
<small>@[@

f_2 =
f_3 \left[ v_1^{(0)} , \ldots , v_2^{(1)} ,
    v_3^{(0)} \left( v_2^{(0)} \right) ,
    v_3^{(1)} \left( v_2^{(1)} \right)
\right]

@]@</small>
It follows that
<small>@[@

\begin{array}{rcll}
\D{f_2}{v_1^{(0)}}
& = & \D{f_3}{v_1^{(0)}}
& =  0.5
\\
\D{f_2}{v_1^{(1)}}
& = & \D{f_3}{v_1^{(1)}}
& =  0.25
\\
\D{f_2}{v_2^{(0)}}
& = & \D{f_3}{v_2^{(0)}}
  +   \D{f_3}{v_3^{(0)}} * \D{v_3^{(0)}}{v_2^{(0)}}
& = 0.5
\\
\D{f_2}{v_2^{(1)}}
& = & \D{f_3}{v_2^{(1)}}
  +   \D{f_3}{v_3^{(1)}} * \D{v_3^{(1)}}{v_2^{(0)}}
& = 1.25
\end{array}

@]@</small>

<br>
<br>
<b><big><a name="Index 2: f_1" id="Index 2: f_1">Index 2: f_1</a></big></b>
<br>
The previous operation has index 1,
<small>@[@

\begin{array}{rcl}
    v_2^{(0)} & = & 1 * v_1^{(0)}
    \\
    v_2^{(1)} & = & 1 * v_1^{(1)}
\end{array}

@]@</small>
We define the function
<small>@(@
f_1 \left( v_1^{(0)} , v_1^{(1)} \right)
@)@</small>
as equal to <small>@(@
f_2
@)@</small>
except that <small>@(@
v_2^{(0)}
@)@</small> and <small>@(@
v_2^{(1)}
@)@</small> are eliminated using
this operation; i.e.
<small>@[@

f_1 =
f_2 \left[  v_1^{(0)} , v_1^{(1)} ,
    v_2^{(0)} \left( v_1^{(0)} \right)  ,
    v_2^{(1)} \left( v_1^{(1)} \right)
\right]

@]@</small>
It follows that
<small>@[@

\begin{array}{rcll}
\D{f_1}{v_1^{(0)}}
& = & \D{f_2}{v_1^{(0)}}
  +   \D{f_2}{v_2^{(0)}} * \D{v_2^{(0)}}{v_1^{(0)}}
& =  1
\\
\D{f_1}{v_1^{(1)}}
& = & \D{f_2}{v_1^{(1)}}
  +   \D{f_2}{v_2^{(1)}} * \D{v_2^{(1)}}{v_1^{(1)}}
& = 1.5
\end{array}

@]@</small>
Note that <small>@(@
v_1
@)@</small> is equal to <small>@(@
x
@)@</small>,
so the second partial derivative of

<code><font color="blue"><span style='white-space: nowrap'>exp_eps(</span></font><i><font color="black"><span style='white-space: nowrap'>x</span></font></i><font color="blue"><span style='white-space: nowrap'>,&nbsp;</span></font><i><font color="black"><span style='white-space: nowrap'>epsilon</span></font></i><font color="blue"><span style='white-space: nowrap'>)</span></font></code>

at 
<code><i><font color="black"><span style='white-space: nowrap'>x</span></font></i></code>
 equal to .5 and 
<code><i><font color="black"><span style='white-space: nowrap'>epsilon</span></font></i></code>
 equal .2 is
<small>@[@

\Dpow{2}{x} v_7^{(0)}
= \D{v_7^{(1)}}{x}
= \D{f_1}{v_1^{(0)}}
= 1

@]@</small>
There is a theorem about algorithmic differentiation that explains why
the other partial of <small>@(@
f_1
@)@</small> is equal to the first partial of

<code><font color="blue"><span style='white-space: nowrap'>exp_eps(</span></font><i><font color="black"><span style='white-space: nowrap'>x</span></font></i><font color="blue"><span style='white-space: nowrap'>,&nbsp;</span></font><i><font color="black"><span style='white-space: nowrap'>epsilon</span></font></i><font color="blue"><span style='white-space: nowrap'>)</span></font></code>

with respect to <small>@(@
x
@)@</small>.




<br>
<br>
<b><big><a name="Verification" id="Verification">Verification</a></big></b>
<br>
The file <a href="exp_eps_rev2.cpp.htm" target="_top"><span style='white-space: nowrap'>exp_eps_rev2.cpp</span></a>
 contains a routine
that verifies the values computed above.
It only tests the partial derivatives of
<small>@(@
f_j
@)@</small> that might not be equal to the corresponding
partials of <small>@(@
f_{j+1}
@)@</small>; i.e., the
other partials of <small>@(@
f_j
@)@</small> must be equal to the corresponding
partials of <small>@(@
f_{j+1}
@)@</small>.

<br>
<br>
<b><big><a name="Exercises" id="Exercises">Exercises</a></big></b>

<ol type="1"><li>
Consider the case where <small>@(@
x = .1
@)@</small>
and we first preform a zero order forward mode sweep
for the operation sequence used above (in reverse order).
What are the results of a
first order reverse mode sweep; i.e.,
what are the corresponding values for
<small>@(@
\D{f_j}{v_k}
@)@</small> for all <small>@(@
j, k
@)@</small> such that
<small>@(@
\D{f_j}{v_k} \neq 0
@)@</small>.
</li><li>

Create a modified version of
<a href="exp_eps_rev2.cpp.htm" target="_top"><span style='white-space: nowrap'>exp_eps_rev2.cpp</span></a>

that verifies the values you obtained for the previous exercise.
Also create and run a main program that reports the result
of calling the modified version of
<a href="exp_eps_rev2.cpp.htm" target="_top"><span style='white-space: nowrap'>exp_eps_rev2.cpp</span></a>
.
</li></ol>



<hr>Input File: introduction/exp_eps.omh

</body>
</html>
